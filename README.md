# Cephalon 自动签到

使用 GitHub Actions 实现每日自动签到。

## 功能

- ✅ 每天自动签到
- ✅ 查询签到历史
- ✅ 失败通知

## 使用方法

1. Fork 本仓库
2. 在 Settings → Secrets 添加 `CHECKIN_TOKEN`
3. 等待每天自动运行

## 手动运行

Actions → 自动签到 → Run workflow

## 更新 Token

Settings → Secrets → CHECKIN_TOKEN → Update

实际上使用了两个目的完全不同的脚本。

简单来说：

复杂版：是我们的“侦察兵”，功能齐全，用来分析和验证签到流程。

简单版：是我们的“狙击手”，目标专一，只用来执行最终的签到。

以下是它们的详细对比：

1. 简单版 (我们最终用于 GitHub Actions 的版本)

这个脚本（cephaloncheckin.py）是我们最终确认方案后，特意精简出来的“执行版”。

核心功能：只做一件事——签到。

工作流程：

启动

调用 POST /signs/today 接口

打印服务器返回的原始信息 (例如: {"code":20002,"msg":"本就完成，无需操作"})

结束

优点：代码干净利落，目标极其明确。非常适合放在 GitHub Actions 这种“跑完就走”的自动化环境中。

缺点：“傻瓜式”执行。它只管按下按钮，但不会主动告诉你“今天签到前是2天，签到后变成了3天”。

2. 复杂版 (你之前提供的、功能更全的版本)

这个脚本更像一个“签到管家”，它不仅执行，还会验证和报告。

核心功能：一个完整的自动化闭环（查询、签到、验证）。

工作流程：

启动

（查询1） 调用 GET /signs/awards 接口，检查奖励信息。

（查询2） 调用 GET /signs 接口，获取签到前的连续天数。

（执行） 调用 POST /signs/today 接口，执行签到。

（验证） 等待几秒后，再次调用 GET /signs 接口，获取签到后的连续天数。

对比两次的天数，打印出更人性化的日志 (例如: 🎉 签到成功！连续签到 3 天)。

结束

优点：

非常“智能”，它会交叉验证自己的工作是否真的生效了。

日志可读性高，能提供更多上下文（比如奖励状态和连续天数）。

缺点：

代码更长，更复杂。

执行多次网络请求，对于一个简单的定时任务来说有点“杀鸡用牛刀”。

总结：我们为什么最后用了“简单版”？

我们最开始之所以那么折腾，是因为我们一直在尝试那个非常复杂的 missions/actives 接口（它需要 mission_uuid 并且总报404）。

“复杂版”脚本是我们的功臣，它帮助我们发现了 signs 和 signs/today 这两个更简单、更稳定的新接口。

一旦我们确认了 POST /signs/today 这个接口（它不需要 uuid，直接发送空数据 {} 就能签到），并且它会明确返回 code: 20002 (已签到) 或 code: 20000 (签到成功)，我们就不再需要那么复杂的验证流程了。

因此，我们最终采用了简单版方案：只调用 signs/today 接口，相信服务器的返回结果。 这对于 GitHub Actions 来说是最高效、最稳妥的选择。
